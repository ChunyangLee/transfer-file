https://github.com/bazelbuild/rules_foreign_cc

https://stackoverflow.com/questions/71023144/how-to-build-header-only-c-library-within-bazel-workspace

看genrule
https://docs.bazel.build/versions/4.1.0/be/general.html#genrule

Args对象
https://docs.bazel.build/versions/main/skylark/lib/Args.html#add_all

----------0925---------------------------
ctx.var ： contains a dict of configuration variables

1. transition
split transition？ transition function can also return a list of dicts or a dict of dicts in the case of a split transition.


2. bazel 扩展， bazel-stack-vscode


测试外部依赖变动，重新构建情况：
1. so有变化，则会重新执行link阶段，
2. 头文件有变化，则重新执行compile阶段，
3.新增h文件，不会重新构建

测试remote-cache
1.ubuntu配置 bazel-remote server  https://linux.cn/article-14871-1.html
docker run -u 0:0 -v /home/code/learn_bazel/bazel_remote_cache:/data  -p 9090:8080 -p 9092:9092 buchgr/bazel-remote-cache

2. INFO: 7 processes: 2 remote cache hit, 5 internal.       （internal是什么？？）

如何debug是否减少时间？
https://docs.bazel.build/versions/4.1.0/remote-caching-debug.html
https://docs.bazel.build/versions/main/remote-execution-caching-debug.html

Faster Bazel builds with remote caching: a benchmark  博客
https://nicolovaligi.com/articles/faster-bazel-remote-caching-benchmark/ 


3. new toolchains, 使用platform，要进行toolchain的选择
Bazel’s C++ rules use platforms to select toolchains when you set --incompatible_enable_cc_toolchain_resolution (#7260).
根据多个flag，--> 一个platform，来选择toolchain, 
用platform_mappings 和 cc_toolchain_suite 解决目录名字问题

待测试 transition， platform，会更改toolchain，---》 已完成
看external/local_config_cc的local例子，



4. 为什么有时候bazel不会cd到sandbox目录执行，有时候会？？
custom_cc_toolchain_with_platforms 例子不会，
crosss-compile的例子就会
答： 都会使用sandbox模式，只是不显示， sandbox_debug模式，执行失败会显示实际去哪个sandbox目录执行的，
execvp permission denied问题是没有执行权限导致的， crosss-compile的例子使用加权限和软连接wrapper的方式解决。


5. 为什么不能按仓给配置文件，
答：因为搜索路径可能交叉在不同仓中，
那么正好配置在一个配置文件中管理，也因此就要体现仓的信息，
每一个external repository的BUILD文件中要 遍历该配置文件，选出仓名==repository_ctx.name的那些，为每个作用域（1）创建rule描述该导入变量的头文件filegroup，配置文件要有一个字段表述filegroup_name， workspace时创建filegroup， 在其他BUILD文件中使用该filegroup、

这样就统一测试代码和业务代码，
增加一个target_custom_setting.bzl文件，配置编译该so的自定义设置，除去工具链默认的，其他自定义修改单个so构建命令的都放在这里，key是target名字，value是字典，按照src，copts属性等，因为是bzl文件，因此可以调用函数（2），把conf里面的*config.bzl里的变量转为直接用的路径或-Iexternal*等，
业务代码编译依赖处理：
一个bzl存放、一个字典描述一个rpm搜索路径，
key可以理解为作用域（1），一个可以被最小导入使用的搜索路径，这样就统一了，业务代码这里看成rpm package，
另一个bzl描述构建so的依赖，目前是按领域，一个领域一个path_group，去挑选上一个bzl的变量，

note: 上面说的（1）作用域变量可以理解为一个path_group,名字可以任意起，内容格式固定，用函数parse_include_paths_from_path_group解析出搜索路径， parse_filegroup_from_path_group得到filegroup的名字，


6.make variables 不饿能直接在repository_rule中使用--define不能用，

<<<<<<< HEAD
=======

7. remote-execute
https://github.com/bazelbuild/bazel-buildfarm

Adapting Bazel Rules for Remote Execution： https://docs.bazel.build/versions/5.2.0/remote-execution-rules.html

Finding Non-Hermetic Behavior in WORKSPACE Rules： https://docs.bazel.build/versions/main/workspace-log.html
Usually non-hermetic behavior is introduced through repository_ctx which allows interacting with the host machine.

https://zhuanlan.zhihu.com/p/513520653

8.bazel-test，
>>>>>>> 129de985de7159d93c9003f08709da586bc78d10
