https://github.com/bazelbuild/rules_foreign_cc

https://stackoverflow.com/questions/71023144/how-to-build-header-only-c-library-within-bazel-workspace

看genrule
https://docs.bazel.build/versions/4.1.0/be/general.html#genrule

Args对象
https://docs.bazel.build/versions/main/skylark/lib/Args.html#add_all

----------0925---------------------------
ctx.var ： contains a dict of configuration variables

1. transition
split transition？ transition function can also return a list of dicts or a dict of dicts in the case of a split transition.


2. bazel 扩展， bazel-stack-vscode


测试外部依赖变动，重新构建情况：
1. so有变化，则会重新执行link阶段，
2. 头文件有变化，则重新执行compile阶段，
3.新增h文件，不会重新构建

测试remote-cache
1.ubuntu配置 bazel-remote server  https://linux.cn/article-14871-1.html
docker run -u 0:0 -v /home/code/learn_bazel/bazel_remote_cache:/data  -p 9090:8080 -p 9092:9092 buchgr/bazel-remote-cache

2. INFO: 7 processes: 2 remote cache hit, 5 internal.       （internal是什么？？）

如何debug是否减少时间？
https://docs.bazel.build/versions/4.1.0/remote-caching-debug.html
https://docs.bazel.build/versions/main/remote-execution-caching-debug.html

Faster Bazel builds with remote caching: a benchmark  博客
https://nicolovaligi.com/articles/faster-bazel-remote-caching-benchmark/ 


3. new toolchains, 使用platform，要进行toolchain的选择
Bazel’s C++ rules use platforms to select toolchains when you set --incompatible_enable_cc_toolchain_resolution (#7260).
根据多个flag，--> 一个platform，来选择toolchain, 
用platform_mappings 和 cc_toolchain_suite 解决目录名字问题

待测试 transition， platform，会更改toolchain，---》 已完成
看external/local_config_cc的local例子，



4. 为什么有时候bazel不会cd到sandbox目录执行，有时候会？？
custom_cc_toolchain_with_platforms 例子不会，
crosss-compile的例子就会
答： 都会使用sandbox模式，只是不显示， sandbox_debug模式，执行失败会显示实际去哪个sandbox目录执行的，
execvp permission denied问题是没有执行权限导致的， crosss-compile的例子使用加权限和软连接wrapper的方式解决。


5. 为什么不能按仓给配置文件，
答：因为搜索路径可能交叉在不同仓中，
那么正好配置在一个配置文件中管理，也因此就要体现仓的信息，
每一个external repository的BUILD文件中要 遍历该配置文件，选出仓名==repository_ctx.name的那些，为每个作用域（1）创建rule描述该导入变量的头文件filegroup，配置文件要有一个字段表述filegroup_name， workspace时创建filegroup， 在其他BUILD文件中使用该filegroup、

这样就统一测试代码和业务代码，
增加一个target_custom_setting.bzl文件，配置编译该so的自定义设置，除去工具链默认的，其他自定义修改单个so构建命令的都放在这里，key是target名字，value是字典，按照src，copts属性等，因为是bzl文件，因此可以调用函数（2），把conf里面的*config.bzl里的变量转为直接用的路径或-Iexternal*等，
业务代码编译依赖处理：
一个bzl存放、一个字典描述一个rpm搜索路径，
key可以理解为作用域（1），一个可以被最小导入使用的搜索路径，这样就统一了，业务代码这里看成rpm package，
另一个bzl描述构建so的依赖，目前是按领域，一个领域一个path_group，去挑选上一个bzl的变量，

note: 上面说的（1）作用域变量可以理解为一个path_group,名字可以任意起，内容格式固定，用函数parse_include_paths_from_path_group解析出搜索路径， parse_filegroup_from_path_group得到filegroup的名字，


6.make variables 不饿能直接在repository_rule中使用--define不能用，



7. remote-execute
https://github.com/bazelbuild/bazel-buildfarm

Adapting Bazel Rules for Remote Execution： https://docs.bazel.build/versions/5.2.0/remote-execution-rules.html

Finding Non-Hermetic Behavior in WORKSPACE Rules： https://docs.bazel.build/versions/main/workspace-log.html
Usually non-hermetic behavior is introduced through repository_ctx which allows interacting with the host machine.

https://zhuanlan.zhihu.com/p/513520653

8.bazel-test，


9. aspect

Parameter values for the aspect are taken from the string attribute with the same name of the rule requesting the aspect (see the definition of file_count_rule).

 Aspects with parameters cannot be used via the command line because there is no syntax to define the parameters
 
 it is an error if a target and an aspect that is applied to it each provide a provider with the same name. The providers that a rule implementation propagates are created and frozen before aspects are applied and cannot be modified from an aspect...
 
 ## 在aspect implementation中根据ctx.rule.attr.deps 访问到的是[A(Y), A(Z)]， 
 ## 因此通过for dep in ctx.rule.attr.deps: dep[FileCountInfo]， 可以获得X的依赖的aspect的provider
 For returning providers, the values of attributes along which the aspect is propagated (from the attr_aspect list) are replaced with the results of an application of the aspect to them. For example, if target X has Y and Z in its deps, ctx.rule.attr.deps for A(X) will be [A(Y), A(Z)]. In this example, ctx.rule.attr.deps are Target objects that are the results of applying the aspect to the ‘deps’ of the original target to which the aspect has been applied.
 
10. custom_setting flag
configurable attribute 只能是  config_setting or constraint_value.
platform只能指定 constraint_value
因此如果想要让attr根据command-line flag变化，那么要使用 User-defined build settings， 放到custom_setting_flags目录下，
再封装成config_setting， 
如果是固定指定platform就可以，使用platform+constraint_value就可以了

----------------------------------------1113

11. action_config测试， 
工具链设置里面可以的，

测试使用genrule？？
使用$(CC) 直接用的是tool_path里面配置的，不会走action_config

！！！note：统一使用工具链来编.o和.so，不分开编，遇到不同过程需要不同flag的场景使用action_config来处理，
!! 也可以自己封装一个  toolchains = ["@bazel_tools//tools/cpp:current_cc_toolchain"], 使用 platform_common.TemplateVariableInfo


12. configurable attribute使用constraint_value    ---> 已完成，select不必一定使用config_setting
官网原话： 
Each key in a configurable attribute is a label reference to a config_setting or constraint_value.


13. third-party-dependencies 最佳实践，

    """Load the transitive dependencies of only our direct dependencies"""

Imagine that we have dependency `A` and dependency `B` and dependency `A` has `B` as a requirement (`A->B`). We have two options, we could declare only `A` in our workspace or `A` and `B`. Let's see what happens in each of the situations:

* **We declare only `A`**: This means that we only load the source code of `A` in the first phase and then on the second phase when loading the transitive dependencies of `A` we will also load the source code of `B`. The implication here is that the version that we will take of `B` will be define in the source code of `A`.

* **We declare `A` and `B`**: This means that we load the source code of `A` and `B` in the first phase and then on the second phase when loading the transitive dependencies of `A` we will not load the source code of `B`. The implication here is that the version that we will take of `B` is the one that we explicitly declared. We will have more control regarding the version of `B` that will be used.


------------------------- 11192047

1. 使用相对路径导入，workspace？ 避免使用V8_root环境变量，
relative_local_repository, 
属性给两个， 
一个path， 一个relative，  组合起来得到真正的path， relative给default当前的workspace，


def _impl_relative_new_local_repository(repository_ctx):
    workspace_dir = repository_ctx.path(Label("//:WORKSPACE")).dirname
    repo_dir_str = '/'.join([str(workspace_dir), repository_ctx.attr.path])
    print(repo_dir_str)

    repo_dir = repository_ctx.path(repo_dir_str)
    print(repo_dir)
    print(repo_dir.exists)
    repository_ctx.symlink(repo_dir, "")
    repository_ctx.file("WORKSPACE")


relative_new_local_repository = repository_rule(
    implementation = _impl_relative_new_local_repository,
    attrs = {
        "path": attr.string(mandatory = True),
        "workspace": attr.label(default = Label("//:WORKSPACE")),
    }
)


---------------------1123
1. bin构建出来但是readelf -d 会出现 segfault，？？？

2. 查询readelf命令？？为什么会出现segfault，才能决定bazel如何构建出bin和怎么执行
先看编译选项是否一致？？


1.如果要除去rpm覆盖的问题，首先去掉cmc_down节点，
	c吗编译没问题，cmake解析依赖，外部依赖从repo拿
	资源没问题， 检查BUILD_RES目录，这里是编出来的，会从ysd下载list去掉，
	打包 --》 只编领域缺少其他领域的包，要下载，采用删除方式，不用cmc_down这种覆盖方式
	下面的节点待分析？
	
	
2. command line options

	
	
--------------------- 1220
1. 问KKinit.c生成那个工具，的输出情况，要声明输出，那两个头文件，
